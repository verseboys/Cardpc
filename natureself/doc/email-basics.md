# 邮件基本知识

## 邮件的结构

邮件在传输的过程中，会使用 [MIME格式](https://en.wikipedia.org/wiki/MIME) 来传输。
因而我们在发送邮件时，首先需要构造出 MIME 结构，然后序列化成 MIME 格式文本，才能发送出去。

大家平时使用客户端或网页发送邮件，或者在程序中使用一些第三方的库来发送邮件，这些工具都对 MIME 格式进行一些抽象。
在大家的认知中，一封邮件主要由这些字段构成：

* 标题
* 发件人、收件人，可能还会有抄送、密送等
* 正文，大家现在接触到的一般都是 HTML 格式的正文，可能还会内嵌图片
* 附件

如果是在渲染一个网页，所有这些东西都会很简单，比如图片可以使用 `<img>` 标签来引入外部资源，附件本质上就是一个外部资源的链接。
然而在邮件中，所有这些内容都需要序列化到一起成为一个整体，并且客户端要有能力将这些内容识别出来，并按照用户期望的方式渲染。

在邮件中，最基本的单位，我们称为 `part`，每一个 part 由一些 header 和 body 组成，一个 part 的 body 可能是最终的内容，
也可能是其他 part（即 sub-part、子part）。每一个邮件都有且仅有一个根part（root part），所有 part 组成一个树状结构。

header 与 HTTP 协议中的 Header 类似，是`键-值对`，用来保存这个 part 相关的元信息。
其中，所有 part 都要求有 `Content-Type` 这个头，来表示这个 part 的内容类型。

part 的内容类型可以分为两大类：*multipart* 和 *non-multipart*，其中 *multipart* 表示它的 body 是其他子part，
*non-multipart* 表示它没有子 part，它的 body 就是自己的内容。我们常见的 `text/plain`, `text/html`, `image/png` 等，
就属于 *non-multipart* 。

*multipart* 中可以分为好多种，常见的有 *alternative*, *related*, *mixed* 等等。
* *alternative* 含有多个 subpart，每一个 part 的类型不同，比如有 text/plain, text/html 等等，
邮件客户端只会渲染其中的一个，一般按顺序从后往前渲染第一个支持的 part。比如一个 alternative part 中有 text/plain 和 text/html
两个 subpart，一个邮件客户端仅支持 text/plain，则它会渲染 text/plain，如果一个客户端支持 text/html，则它会渲染 text/html。
* *related* 表示其多个 subpart 是相互依赖，必须同时渲染才有意义。一般第一个 part 是 root part，客户端会渲染这个 part，
而这个 part 会依赖其他 part 的内容。最常见的用法是带有内嵌图片的网页，第一个 part 是网页 text/html，后面的 part 是内嵌的图片，
在网页中可以引用这些图片（具体方法稍后介绍）。
* *mixed* 表示有多个内容，常用于整个邮件的 root part。客户端应该渲染这下面的每一个子 part。
（注意，这里的 *渲染* 一词并不表示浏览器一定要显示每一个 part，一个 part 如何被显示，还由 *Content-Disposition* 头决定。）

因此，一个完整的邮件可能是这样的结构：

```
* multipart/mixed (root part)
.   * multipart/alternative
.   .   * text/plain
.   .   * multipart/related
.   .   .   * text/html
.   .   .   * image/png (inline image 1)
.   .   .   * image/png (inline image 2)
.   .   .   * ...
.   * application/octet-stream (attachment 1)
.   * application/octet-stream (attachment 2)
.   * ...
```

这封邮件由正文和若干附件组成（这里的 *正文* 只是我们口头上的说法，对于客户端来说，第一个子 part 是可以渲染的，为了方便沟通，
我们称之为正文），正文有纯文本和带内嵌图片的网页两个 part 组成，现在的客户端都支持 html，因此会渲染网页的部分，纯文本的部分会被忽略。

由于现在绝大多数邮件客户端都支持渲染网页（text/html），尤其是我们网站的客户使用的客户端一定是支持网页的（
不支持的那部分极大概率不是我们的目标客户）。不支持网页的客户端主要有：

* 一些很老的客户端
* 一些基于命令行的客户端（其实现在基于命令行的客户端也支持网页，当然渲染的效果受限）
* 一些用于由于特殊的原因，例如为了节省流量，配置了客户端让客户端优先渲染纯文本

显然，我们是不用考虑这些情况的。

因此，针对我们的场景，我们所有的邮件都可以按照这样的结构来构造：

```
* multipart/mixed (root part)
.   * multipart/related
.   .   * text/html
.   .   * image/png (inline image 1)
.   .   * image/png (inline image 2)
.   .   * ...
.   * application/octet-stream (attachment 1)
.   * application/octet-stream (attachment 2)
.   * ...
```

即使一封邮件不需要 html，只需要纯文本，我们也可以把纯文本的内容放在 'text/html' 中，也是可以正常显示的。
因此，一封最简单的邮件，即没有图片，也没有附件，只有正文的部分，构造的结构如下：

```
* multipart/mixed (root part)
.   * multipart/related
.   .   * text/html
```

实际上，这样简单的邮件只需要一个 *text/html* 作为 root part 就行，不过我们使用上面的这种“万能”结构，可以简化我们的代码。
我们的代码无需判断是否有内嵌图片、是否有附件来调整邮件结构。

## Django 中发邮件

Django 封装了一个 `send_mail()` 函数来发送邮件，官方文档见：https://docs.djangoproject.com/en/2.1/topics/email/ 。
我们首先看一下它的签名：

```py
send_mail(subject, message, from_email, recipient_list, fail_silently=False, auth_user=None, auth_password=None, connection=None, html_message=None)
```

在不了解前面关于 MIME 结构的基础知识的情况下，可能对这里的 `message` 、 `html_message` 参数有误解，可能会误以为
如果两个参数都提供了，那么最终两部分内容都会在客户端中被显示。实际上，这里的 `message` 和 `html_message` 是封装到了
一个 *multipart/related* 下面，因此只有 `html_message` 的部分会被显示。

这个函数无法发送含有内嵌图片和附件的邮件，它构造的结构如下：

```
* multipart/related
.   * text/plain
.   * text/html
```

如果要发送复杂的邮件，比如含有内嵌图片、附件等的邮件，需要使用 `django.core.mail.EmailMessage` 或
`django.core.mail.EmailMultiAlternatives` 来手动构造。

## 如何内嵌图片

在网页中嵌入图片主要有两种方式，一种是引用外部资源，一种是通过 data url 直接把图片数据内嵌在网页里：

```html
<img src="http://.../xxx.png">
<img src="data:image/png;base64,aGVsbG8=...">
```

在邮件中，这两种方式都有问题：

* 引用外部图片，许多邮件客户端出于反追踪或防止恶意数据的原因，会默认不显示外部的图片，需要用户点击确认才会显示
* data url，有许多邮件客户端不支持 data url，无法显示这样的图片

在邮件中要想可靠的显示图片，只有一种方式，将图片放到 *multipart/related* 中，然后在网页里引用。
图片这个 part 还需要增加两个 Header： `Content-Disposition` 和 `Content-ID`。

`Content-Disposition` ，这个其实所有的附件、内嵌图片都必须要加，告诉客户端如何处理这个 part。对于没有这个 header 的 part，
客户端一般直接渲染（比如 text/plain、text/html 等等）。这个 Header 可以有 `inline` 和 `attachment` 两种取值：

```
Content-Disposition: inline
Content-Disposition: attachment
```

当取值为 `inline` 时，表示这个内容需要直接展示，一般内嵌图片使用 `inline`。`attachment` 则告诉客户端这是一个附件，
请给用户提供“下载”的按钮。

`Content-Disposition` 中还可以提供文件名信息，例如一个附件该显示为什么文件名，可以这样控制：

```
Content-Disposition: attachment; filename=abc.txt
```

这样，客户端中渲染的附件名就是 `abc.txt` 。

`Content-Disposition` 中还可以提供其他信息，我们这里不展开讨论。

`Content-ID` 则提供了被引用的方法，例如某个图片的 Header：

```
Content-Type: image/png
Content-Disposition: inline
Content-ID: abc
```

则在网页中可以这样引用：

```html
<img src="cid:abc">
```

如果一个图片没有被网页中引用，不同的客户端采用的方式可能就不一样了，比如 gmail 会把这个图片当作附件处理。我们要避免这种情况。

## 关于邮箱地址

在邮件的 Header 中有许多字段与邮箱地址有关，比如：`From`, `To`, `Reply-To`, `Cc` 等等（注意，并没有 `Bcc` 这个头）。
其中一些头只允许一个地址，比如 `From`，有些头允许多个地址，比如 `To`, `Reply-To`, `Cc` 等。当有多个地址时，使用英文逗号 `,` 分隔。

邮箱的地址可以有两种格式：

* 纯地址，如：`xxx@example.com`
* 带显示名称的地址，如：`Zhang San <zhangsan@example.com>`

在 Header 中，两种地址都支持。当使用第二种地址时，客户端渲染的时候可以渲染名字。在 Django 提供的 `send_mail`，
以及我们自己封装的 `send_mail` 函数，都支持这两种地址。

邮件的 Header 中不支持非 ascii 字符，因此，如果 *显示名* 中含有中文时，这样的 Header 是非法的：

```
To: 张三 <zhangsan@example.com>
```

虽然有一些邮件客户端可以正常显示，但大多数客户端可能都无法显示或显示为乱码。我们需要对显示名进行编码，
使用的编码方式叫 *quoted-printable*，编码后的 Header 长这样：

```
To: =?utf-8?b?5byg5LiJ?= <zhangsan@example.com>
```

如果使用 Django 封装的 `send_mail` 或者我们自己封装的 `send_mail`，都已经处理好了这个 Header。
但如果使用 Python 内建但 `email` 库来手动构建邮件，则需要自行处理。

编码中文内容的方法如下：

```
from email.header import make_header
make_header([('张三', 'utf-8')])   # 输出 =?utf-8?b?5byg5LiJ?=

# 或者
from email.header import Header
Header('张三', 'utf-8').encode()
```

其他 Header 类似，例如邮件标题中如果含有非 ascii 字符，同样需要做这个处理。

## 附件的文件名

附件的文件名是在 `Content-Disposition` 中通过 `filename` 来指定的，同样因为是 Header，所以不支持中文，
要使用中文，需要编码。但是， `Content-Disposition` 中不支持 `quoted-printable` 这种编码方式，需要使用 RFC 2231 来编码。
在 Python 中比较简单：

```py
part = MIMEBase(maintype, subtype)  # 例如 part = MIMEBase('image', 'png')
part.add_header('Content-Disposition', 'attachment', filename='中文.png')
```

## 拓展阅读，邮件是如何发送的

由于现代的邮箱产品做了许多封装，大多数人（以及大多数开发者）都并不了解邮件是如何发送的。大家的概念中，要发送邮件，需要：

* 注册某一个邮箱，比如注册 126 邮箱
* 登录该邮箱
* 撰写邮件、并发送

在大家的概念中，「邮箱」是一个网页，可以浏览邮件，可以发送邮件。但是当写程序时却发现有时候并不是这样，因而十分费解。
例如，我们之前在开发发送邮件的功能时，有一位开发者问我「怎样登录这个邮箱」。

其实，电子邮件系统，与传统的邮件系统十分相似。传统的邮件系统中包含这些元素：

* *收件箱* ，国内可能比较少，国外许多人家门口会有一个收件箱，国内一些小区的楼下也会有收件箱，大家更常见的形式还有传达室，
或者没有实体的信箱，信箱地址直接是家庭地址，邮差送信时，送到该地址后直接给某个人，这种情况下，我们认为这个家庭地址就是一个收件箱。
简单的说，**一个收件箱是一个可投递的地址**。
* *信封* ，在信封上我们可以写上发件人地址，收信人地址，以及其他随便什么乱七八糟的信息。
其中只有收件人地址是必填的，这个地址是一个 *收件箱* 的地址。发件人信息则可填可不填，也可以填一个假的
（国内现在要求发件人实名，这属于特殊情况，就邮件系统本身来说，发件人地址并不是必填的，如果不填或者填假的，
后果是发生退信时无法送回来，对方也无法回信）
* *邮局* ，大家在写好信之后，需要将信封交给邮局（可以自己直接送到邮局，也可以塞到某一个邮箱里，邮局会定时取，
这两种情况我们都认为信件已经交给了邮局，即大街上的邮箱属于邮局的一部分）。

当信封交给邮局之后，邮局根据信封上的收信人地址，将邮件送到离收信人最近的一个邮局，然后该邮局会进一步将信封投递到收件人的收件箱中。
我们看到，在邮件系统中，**邮局的功能就是转送（relay）和投递(dispatch)**，将一个信封转送给另一个邮局，或者投递到某一个信箱中。
实际上，许多邮件并不是一步送达的，中间可能会辗转多个邮局，例如可能先送到目标所在省的邮局、再送往地级市邮局、
再送往县城邮局、然后是乡镇邮局，最后才被投递。还有可能中间送错了邮局，例如发送到了另一个省，
这时候那个邮局也会尝试向正确的邮局转送（注，这里的「送错邮局」实际上指的是没有走最优路径，其实你送给哪个邮局都一样，
只要最终能投递到收件人的收件箱里，就是对的，没有错误一说）。一般来说每个邮局都有自己的管辖范围，只能往自己辖区投递，
例如，海淀区的邮局只能把信件投递到海淀区的某个收件箱，而无法投递到朝阳区的某个收件箱，因此，
假设有一封邮件的收件箱地址是朝阳区，但是由于某种原因被送到了海淀区邮局，海淀区邮局就会把这封信转送给朝阳区邮局。
朝阳区邮局收到这封信之后，发现收件箱就在自己辖区，于是就会直接投递，而不会再转送给其他邮局了。

我们可以在信封里的信纸上写上一些额外的信息。比如“如果回信，请回复到xxx地址”，比如“请将该信件复印后给张三、李四都看一下”。
我们后面会看到，这些概念在电子邮件中都有对应的实现。

在电子邮件系统中，邮局其实就是一个程序，可以在任何地方运行，任何人都可以搭建邮局。
大多数 Linux 发行版都预装了 exim 或者 postfix，这两个软件就是最常见的邮局软件。
在 Linux 中，可以直接使用下面的命令发送邮件（注：不同的Linux发行版中，`mail` 命令的参数可能不同）：

```sh
mail -s '邮件标题' to@example.com < 邮件内容.txt
```

这条命令实际上是构造了一封邮件，用 smtp 协议发送到了本地的邮局（postfix），本地邮局会根据收件人地址中的域名，
找到收件人辖区的邮局（通过查询DNS，example.com 的 NS 记录中的IP即为该邮局的地址），把邮件转送到这个邮局。
当然，postfix 也可以不直接将邮件转送给这个邮局，而是将邮件转送给另外一个邮局，由那个邮局负责继续转送。
邮局在转送（relay）邮件时，使用的协议一般也都是 smtp。邮局在投递（dispatch）邮件时，方法就有很多了，稍后介绍。

但是，我要收信怎么办？我需要一个收件箱，并且这个收件箱具有互联网可访问的地址。
在 Linux 中，最简单的收件箱就是一个 mbox 格式的文件。假设我这台 Linux 有公网IP，可以直接从公网访问。
并且我有一个域名 zhangsan.com，我配置了 zhangsan.com 的 NS 记录为我的公网IP，那么，互联网上的人就可以给 `*@zhangsan.com` 发送邮件了。
这些邮件会被转送到我电脑上的 postfix 上，然后 postfix 会按照配置的规则去投递。
例如把发给 a@zhangsan.com 的邮件保存到 a.mbox 这个文件里，发送给 b@zhangsan.com 的邮件保存到  b.mbox 这个文件里。
邮局如何投递是可以配置的。比如我们可以设置一个规则，让 postfix 把所有 `a*@example.com` 的邮件都投递到 a.mbox 里面。
读取邮件很简单，直接用文本编辑器打开 mbox 文件即可阅读。早年的邮件都是纯文本的，并且都是英文的内容，所以 mbox
文件直接读没有什么问题。但是现在的邮件都是多媒体内容，文本编辑器就很鸡肋了，于是我们需要有邮件客户端来渲染邮件的内容。

可以看到，电子邮件系统的基本运作方式跟传统邮件系统是完全一样的，有 *邮局* 、*收件箱* 、*信件（或者说信封）* 等三部分组成。
传统邮件的信纸是可以直接使用肉眼读的，但是电子邮件则需要 *客户端程序* 来解析、渲染邮件内容。

我们简单总结一下，要发送邮件，需要有邮局和对方的收件箱地址（并不要求自己有收件箱），而要收件，则必须有收件箱，
并且一个收件箱一定是属于某一个邮局管辖的。在传统邮件系统中，收件箱一般由所在的行政辖区管辖，在电子邮件中，
邮箱地址中的域名即为管辖邮局的地址。

然而，这样收信很麻烦，大多数人的电脑没有公网IP，所以无法在本地运行一个邮局以及配置收件箱。于是就有了公共邮局，
比如有企业或组织搭建了一个邮局，域名是 example.com，它就可以收信了，但是收件箱如何配置呢？
用户可以到这个邮局这里“注册”一个收件箱，邮局是公共的、但收件箱是私人的，因此大家会给每一个收件箱设置一个账号密码，
这样，每个用户就只能访问自己的收件箱了。

那么，用户如何访问这个收件箱呢？大家需要使用 *邮件客户端*（对，又是邮件客户端，所以邮件客户端的功能不仅仅是渲染邮件，
还可以撰写邮件、收发邮件等等）。邮件客户端使用 POP3 协议登录到收件箱（注意，登录的不是邮局，而是收件箱），并将收件箱
中的邮件下载到本地，然后渲染给用户查看。

使用邮件客户端非常方便，实际上现在的邮件客户端除了基本的邮件收发功能外，还集成了许多额外的功能，比如日程管理，
收藏夹等等，用来管理邮件内容，乃至管理个人日常事务。

但是，使用邮件客户端还是需要一些学习成本，大家至少需要配置两样东西：收件箱地址（一般就是 pop3 服务器地址和账号），
发信邮局地址（一般就是 smtp 地址和账号）。有没有更简单的方法呢？

现在大多数邮件服务商都会提供一个「网页版的邮箱服务」，这就是大家常说的「邮箱」。实际上，这个网页就是一个邮件客户端，
它背后已经配置好了 pop3 地址、smtp 地址，因此你只需要登录网页就可以了。这个网页客户端可以显示你信箱里的所有邮件，
可以渲染这些邮件，你也可以发送邮件。（当然，因为网页、收件箱、邮局都是由同一个服务商提供的，他们内部就不必须用
pop3、smtp 协议了，内部可能有更好的通信方式，这里这样讲只是为了容易理解）。

实际上，大多数邮箱服务都还提供了“代收信”功能，你可以配置一个其他邮箱的 pop3 地址，它会在后台帮你去抓取其他信箱里的邮件。
有一些邮件服务还允许你配置其他的 smtp 服务器，比如 gmail，在发信的时候，你可以选择使用哪一个 smtp 服务器来发信。
因此，gmail 实际上是一个「全功能」的基于 web 网页的邮件客户端，它的功能甚至比绝大多数 PC 版的邮件客户端都丰富。

在正确认识什么是「邮箱」这个东西之后，我们再来看一些大家可能不那么常见的细节，以 QA 的方式来组织内容吧。

**Q**：发邮件时可不可以不填收件人？发给邮局时必须要登录吗？

**A**：与传统邮件系统一样，发电子邮件可以不填发信人。不过许多客户端会强制要求填，但在电子邮件协议层面，这并不是必须的。
大家也可以观察，有些收到的垃圾邮件的发件人就是空的。

这实际上使得发送垃圾邮件非常容易，假设我要发送广告邮件，不需要用户回信，因此我发送邮件时可以随便写一个发信人或者干脆不写。
因此，现在许多反垃圾邮件系统会直接拒掉发信人为空的邮件。那么，如果我填一个假的地址，比如 zhangsan@google.com ，反垃圾邮件系统如何识别呢？
（注，反垃圾邮件系统可以运行在邮件转送过程中的任意环节，其中的任何一个邮局都可能运行了反垃圾邮件系统，将识别出来的垃圾邮件丢弃。）

对于运行在网络上的反垃圾邮件系统来说，它是无法识别一封邮件背后的真人是谁，所以它无法确认你是不是拥有 zhangsan@google.com
这个信箱的控制权。但是可以这样做，可以存在一种方法来判断这封邮件是不是从 google 这个邮局发出来的，
而 google 这个邮局则可以保证：
1) 从我这里发出去的邮件，发件人一定是 @google.com，不会是 @baidu.com
2) 我对我发出去的内容负责，即我会尽可能的过滤掉可能的垃圾邮件，不给接收方找麻烦

这里，判断一封邮件是不是从 google 发出来的，方法有两个：
* SPF 记录
* DKIM 签名

SPF 记录是一个 DNS 的 TXT 记录，比如一个邮局收到了来自另一个邮局（IP地址是 1.2.3.4）发来的邮件，发信人域名是 google.com，
这个邮局会查询 google.com 的 SPF 记录，从 SPF 记录中可以获取到 google.com 邮局所有的公网IP，然后看 1.2.3.4 是否在这个IP列表中，
如果在，则说明这封邮件确实是从 Google 邮局转送来的，否则就说明不是从 Google 邮局转送来的。

DKIM 签名则是一个比 SPF 更强的校验方式。Google 邮局在转送邮件时，会给这个邮件签名，目标邮局收到邮件后，
可以从 google.com 的 DNS 中找到该签名的公钥，然后校验签名是否正确，如果不正确，说明这个邮件不是来自 google 邮局。

而 Google 邮局方面，又怎样保证发件人不伪造发件箱地址呢？很简单，让用户登录即可。用户发信有两种方式：

* 使用 web 客户端发信，在 web 客户端中功能可以直接不让用户填写发信人，发信人由系统自动填写，因此不会造假
* 使用 smtp 发信，发信人实际上是邮件内容中 From 这个 Header 的值，用户可以随便填，Google 可以直接拒绝掉 From 不是
相应用户的邮件，或者强制把 From 改成登录用户的值之后再转送。

实际上，Google 邮局还会做许多其他的限制，比如限制一个人单位时间里最多只能发送多少邮件，以避免滥用。

**Q**: 发信邮局和收件箱一定在一起吗？

从前面的原理介绍中看到，这并不必须，而实际上通常也都不在一起。只不过大家平时如果只用 web 发信的话，接触不到这些概念，
因此也无法判断。我们以公司的企业邮箱举例介绍。

比如公司的企业邮箱由阿里云提供（阿里云提供了一整套东西，即邮局、收件箱、web客户端），域名是 natureself.cn。
我们可以登录阿里云 web客户端收发邮件，也可以配置本地客户端去收发邮件（实际上配置本地客户端时，就会知道发信邮局和收件箱地址
是两个不同的地址，因此肯定也是不同的服务器）。

现在，假设我们需要发送推广邮件，或者在程序里发送通知邮件（总之就是用程序发邮件）。
这时候，许多人首先想到的方法，就是去阿里云邮箱管理后台创建一个新账号，然后程序里用这个账号登录了去发送邮件。
但显然这并不是必须的，而且一般不会这么做。这里创建的账号会有许多限制，例如阿里云肯定也会限制单位时间内发送邮件的数量。

这种情况下，我们一般会使用第三方的发信邮局服务。这种邮局只提供发信服务，不提供收信服务。
比如阿里云邮件推送服务（虽然都是阿里云的，但是跟阿里云企业邮箱是独立的两个东西），比如运维这边在用的 mailgun 等等。
我们可以让我们的程序把信件投递给这些邮局，他们会负责转送邮件。

如何使用这些第三方服务呢？前面介绍了 SPF 和 DKIM，我们都需要设置。比如我们使用 mailgun，那么我们需要将 mailgun 的邮局地址
也加入到我们的 SPF 记录中，mailgun 会对它发出的邮件用 DKIM 前面，因此我们要把这个签名的公钥加入我们的 DNS 记录中。
（注，一个域名下可以配置许多 SPF 记录和 DKIM 公钥记录。）

我们的程序与这些服务商之间如何通信呢？大多数此类服务商都会提供两种方式，smtp 和 HTTP API。

使用这类服务时，我们需要创建一个账号，注意，因为这个服务仅仅是发信服务，因此这个账号跟邮件地址没有任何关系，
这个账号仅仅用于 smtp 或 http api 通信时的权限认证。在注册账号之后，服务商会通过一些手段来验证我们拥有的域名，
比如我们有 natureself.cn 这个域名，我可以向服务商证明我拥有这个域名（具体方式这里不展开）。验证之后，
我使用这个服务商邮局发信时，发件人就可以写任意的 `*@natureself.cn` 了。

我们与服务商之间通信，验证账号时，一般很少用用户名密码的方式，常见的是用 key/secret 的方式。
它与账号密码方式的区别是，一个账号可以创建多个 key/secret，随时可以生成新的 key、弃用旧的 key。
这样，阿里云的账号可能公司里就只有一两个人有，开发者不需要阿里云的账号，只要有一对 key/secret 就行了。

**Q**: 密送（Bcc）是如何实现的？

**A**: 密送的功能，实际收到邮件的人不在 To 或者 Cc 里面，实际上，如果大家使用过一些邮箱自动转发的功能，
可以将邮件原封不动的投递到指定邮箱中。有心人可能发现，在邮件的 Header 中并没有 `Bcc` 这个头，
而且从使用意图上说也不应该有这个头，否则密送的意义就没有了。

实际上，我们构造的 MIME 结构中的所有内容都只是信纸，并非信封。因此，Header 里写的 From, To, Cc, Reply-To 等等，
其实都是信纸上的内容，而不是写在信封上的，而邮箱也并不关心这些内容（需要根据 From 来过滤垃圾邮件的特例除外）。
这些内容都只是给收信人看的，这些内容并不能保证真实，毕竟你可以在信纸上随意写任何内容。

实际上，我们在使用 smtp 发信的时候，除了将信纸提交给邮局之外，还需要额外提供收件人列表，这份列表就是信封上的内容。
最终用户是看不到信封的，大家在客户端中查看到的都是信纸。信封上的收件人列表可以跟信纸上的收件人完全不同。

我们在用客户端发邮件时，填写了收件人、抄送人、密送人之后，客户端在使用 smtp 发信时，会把所有这些地址整合起来放在
信封的收件人列表里。实际上，信封上只有收件人，没有抄送、密送之类的概念。
